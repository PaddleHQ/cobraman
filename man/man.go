// Copyright 2015 Red Hat Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package man

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"
	"time"

	"github.com/spf13/cobra"
	"github.com/spf13/pflag"
)

const defaultManTemplate = `.TH "{{.DashedCommandPath | upper}}" "{{ .Section }}" "{{.CenterFooter}}" "{{.LeftFooter}}" "{{.CenterHeader}}" 
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.SH NAME
{{ .DashedCommandPath }}
{{- if .ShortDescription }} - {{ .ShortDescription }}
 {{- end }}
.SH SYNOPSIS
.sp
{{ .Synopsis }}
.SH DESCRIPTION
.PP
{{ .Description }}
{{- if .AllFlags }}
.SH OPTIONS
{{ range .AllFlags -}}
.TP
{{ if .Shorthand }}\fB{{ print "-" .Shorthand | backslashify }}\fP, {{ end -}}
\fB{{ print "--" .Name | backslashify }}\fP{{ if not .NoOptDefVal }} = {{ .DefValue }}{{end}}
{{ .Usage | backslashify }}
{{ end }}
{{- end -}}
{{- if .Environment }}
.SH ENVIRONMENT
.PP
{{ .Environment }}
{{- end }}
{{- if .Files }}
.SH FILES
.PP
{{ .Files }}
{{- end }}
{{- if .Bugs }}
.SH BUGS
.PP
{{ .Bugs }}
{{- end }}
{{- if .Examples }}
.SH EXAMPLES
.PP
{{ .Examples }}
{{- end }}
{{- if .Author }}
.SH AUTHOR
.PP
{{.Author}}
{{- end }}
{{- if .HasSeeAlso }}
.SH SEE ALSO
{{ .SeeAlsos }}
{{- end }}
." This file auto-generated by github.com/rayjohnson/cobra-man
`

// GenerateManOptions is used configure how GenerateManPages will
// do its job.
type GenerateManOptions struct {
	// What section to generate the pages 4 (1 is the default if not set)
	Section string

	// CenterFooter used across all pages (defaults to current month and year)
	// If you just want to set the date used in the center footer use Date
	CenterFooter string

	// If you just want to set the date used in the center footer use Date
	Date *time.Time

	// LeftFooter used across all pages
	LeftFooter string

	// CenterHeader used across all pages
	CenterHeader string

	// Files if set with content will create a FILES section for all
	// pages.  If you want this section only for a single command add
	// it as an annotation: cmd.Annotations["man-files-section"]
	// The field will be sanitized for troff output. However, if
	// it starts with a '.' we assume it is valid troff and pass it through.
	Files string

	// Bugs if set with content will create a BUGS section for all
	// pages.  If you want this section only for a single command add
	// it as an annotation: cmd.Annotations["man-files-section"]
	// The field will be sanitized for troff output. However, if
	// it starts with a '.' we assume it is valid troff and pass it through.
	Bugs string

	// Environment if set with content will create a ENVIRONMENT section for all
	// pages.  If you want this section only for a single command add
	// it as an annotation: cmd.Annotations["man-environment-section"]
	// The field will be sanitized for troff output. However, if
	// it starts with a '.' we assume it is valid troff and pass it through.
	Environment string

	// Author if set will create a Author section with this content.
	Author string

	// Directory location for where to generate the man pages
	Directory string

	// CommandSperator defines what character to use to separate the
	// sub commands in the man page file name.  The '-' char is the default.
	CommandSeparator string

	// GenSeprateInheiratedFlags will generate a separate section for
	// inherited flags.  By default they will all be in the same OPZTIONS
	// section.
	GenSeprateInheritedFlags bool

	// UseTemplate allows you to override the default go template used to
	// generate the man pages with your own version.
	UseTemplate string
}

// GenerateManPages - build man pages for the passed in cobra.Command
// and all of its children
func GenerateManPages(cmd *cobra.Command, opts *GenerateManOptions) error {
	for _, c := range cmd.Commands() {
		if !c.IsAvailableCommand() || c.IsAdditionalHelpTopicCommand() {
			continue
		}
		if err := GenerateManPages(c, opts); err != nil {
			return err
		}
	}
	section := "1"
	if opts.Section != "" {
		section = opts.Section
	}

	separator := "-"
	if opts.CommandSeparator != "" {
		separator = opts.CommandSeparator
	}
	basename := strings.Replace(cmd.CommandPath(), " ", separator, -1)
	if basename == "" {
		return fmt.Errorf("you need a command name to have a man page")
	}
	filename := filepath.Join(opts.Directory, basename+"."+section)
	f, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer f.Close()

	return generateManPage(cmd, opts, f)
}

type manStruct struct {
	Section      string
	CenterFooter string
	LeftFooter   string
	CenterHeader string

	UseLine           string
	CommandPath       string
	DashedCommandPath string
	ShortDescription  string
	Description       string
	Synopsis          string

	HasFlags          bool
	Flags             string
	HasInheritedFlags bool
	InheritedFlags    string
	AllFlags          []pflag.Flag

	HasSeeAlso bool
	SeeAlsos   string

	Author      string
	Environment string
	Files       string
	Bugs        string
	Examples    string
}

func generateManPage(cmd *cobra.Command, opts *GenerateManOptions, w io.Writer) error {
	var flags *pflag.FlagSet
	values := manStruct{}

	// Header fields and NAME
	values.LeftFooter = opts.LeftFooter
	values.CenterHeader = opts.CenterHeader

	values.Section = opts.Section
	if values.Section == "" {
		values.Section = "1"
	}

	date := opts.Date
	if opts.Date == nil {
		now := time.Now()
		date = &now
	}
	values.CenterFooter = opts.CenterFooter
	if opts.CenterFooter == "" {
		values.CenterFooter = date.Format("Jan 2006")
	}

	dashCommandName := strings.Replace(cmd.CommandPath(), " ", "-", -1)
	values.DashedCommandPath = dashCommandName
	values.ShortDescription = cmd.Short

	// SYNOPSIS
	values.Synopsis = generateSynopsis(cmd)
	values.UseLine = cmd.UseLine()
	values.CommandPath = cmd.CommandPath()

	// DESCRIPTION
	description := cmd.Long
	if len(description) == 0 {
		description = cmd.Short
	}
	values.Description = simpleToTroff(description)

	// Options
	flagArray := make([]pflag.Flag, 0, 15)
	cmd.Flags().VisitAll(func(flag *pflag.Flag) {
		if len(flag.Deprecated) > 0 || flag.Hidden {
			return
		}
		flagArray = append(flagArray, *flag)
	})
	values.AllFlags = flagArray

	if opts.GenSeprateInheritedFlags {
		flags = cmd.NonInheritedFlags()
	} else {
		flags = cmd.Flags()
	}
	if flags.HasFlags() {
		values.HasFlags = true
		buf := new(bytes.Buffer)
		printFlags(buf, flags)
		values.Flags = buf.String()
	}
	if opts.GenSeprateInheritedFlags {
		flags = cmd.NonInheritedFlags()
		values.HasInheritedFlags = true
		buf := new(bytes.Buffer)
		printFlags(buf, flags)
		values.InheritedFlags = buf.String()
	}

	// ENVIRONMENT section
	altEnvironmentSection, _ := cmd.Annotations["man-environment-section"]
	if opts.Environment != "" || altEnvironmentSection != "" {
		if altEnvironmentSection != "" {
			values.Environment = simpleToTroff(altEnvironmentSection)
		} else {
			values.Environment = simpleToTroff(opts.Environment)
		}
	}

	// FILES section
	altFilesSection, _ := cmd.Annotations["man-files-section"]
	if opts.Files != "" || altFilesSection != "" {
		if altFilesSection != "" {
			values.Files = simpleToTroff(altFilesSection)
		} else {
			values.Files = simpleToTroff(opts.Files)
		}
	}

	// BUGS section
	altBugsSection, _ := cmd.Annotations["man-bugs-section"]
	if opts.Bugs != "" || altBugsSection != "" {
		if altBugsSection != "" {
			values.Bugs = simpleToTroff(altBugsSection)
		} else {
			values.Bugs = simpleToTroff(opts.Bugs)
		}
	}

	// EXAMPLES section
	altExampleSection, _ := cmd.Annotations["man-examples-section"]
	if cmd.Example != "" || altExampleSection != "" {
		if altExampleSection != "" {
			values.Examples = simpleToTroff(altExampleSection)
		} else {
			values.Examples = simpleToTroff(cmd.Example)
		}
	}

	// AUTHOR section
	if opts.Author != "" {
		values.Author = opts.Author + "\n.PP\n.SM Page auto-generated by rayjohnson/cobra-man and spf13/cobra"
	}

	// SEE ALSO section
	values.HasSeeAlso, values.SeeAlsos = generateSeeAlso(cmd, values.Section)

	// Build the template and generate the man page
	manTemplateStr := defaultManTemplate
	if opts.UseTemplate != "" {
		manTemplateStr = opts.UseTemplate
	}
	funcMap := template.FuncMap{
		"upper":        strings.ToUpper,
		"backslashify": backslashify,
	}
	parsedTemplate, err := template.New("man").Funcs(funcMap).Parse(manTemplateStr)
	if err != nil {
		return err
	}
	err = parsedTemplate.Execute(w, values)
	if err != nil {
		return err
	}
	return nil
}

func generateSynopsis(cmd *cobra.Command) string {
	// So many ways one could do a synopsis.
	buf := new(bytes.Buffer)
	if cmd.HasSubCommands() {
		for _, c := range cmd.Commands() {
			if c.IsAdditionalHelpTopicCommand() {
				continue
			}
			buf.WriteString(fmt.Sprintf("\\fB%s\\fR [ flags ]\n", c.CommandPath()))
			buf.WriteString(".br\n")
		}
	} else {
		buf.WriteString(fmt.Sprintf("\\fB%s\\fR ", cmd.CommandPath()))
		flags := cmd.Flags()
		if flags.HasFlags() {
			printSynFlags(buf, flags)
		}
		_, exists := cmd.Annotations["man-no-args"]
		if !exists {
			buf.WriteString("[<args>]")
		}
	}
	return buf.String()
}

func printSynFlags(buf *bytes.Buffer, flags *pflag.FlagSet) {
	flags.VisitAll(func(flag *pflag.Flag) {
		if len(flag.Deprecated) > 0 || flag.Hidden {
			return
		}
		if len(flag.Shorthand) > 0 && len(flag.ShorthandDeprecated) == 0 {
			buf.WriteString(fmt.Sprintf("[\\fI\\-%s\\fP|\\FI\\-\\-%s\\FP] ", flag.Shorthand, backslashify(flag.Name)))
		} else {
			buf.WriteString(fmt.Sprintf("[\\fI\\-\\-%s\\fP] ", backslashify(flag.Name)))
		}
	})
}

func printFlags(buf *bytes.Buffer, flags *pflag.FlagSet) {
	flags.VisitAll(func(flag *pflag.Flag) {
		if len(flag.Deprecated) > 0 || flag.Hidden {
			return
		}
		format := ".TP\n"
		if len(flag.Shorthand) > 0 && len(flag.ShorthandDeprecated) == 0 {
			format += fmt.Sprintf("\\fB\\-%s\\fP, \\fB\\-\\-%s\\fP", flag.Shorthand, backslashify(flag.Name))
		} else {
			format += fmt.Sprintf("\\fB\\-\\-%s\\fP", backslashify(flag.Name))
		}
		if len(flag.NoOptDefVal) > 0 {
			format += "["
		}
		format += "=\\fI%s\\fR"
		if len(flag.NoOptDefVal) > 0 {
			format += "]"
		}
		format += "\n%s\n"
		str := fmt.Sprintf(format, backslashify(flag.DefValue), backslashify(strings.TrimRight(flag.Usage, " \n")))
		buf.WriteString(str)
	})
}

func generateSeeAlso(cmd *cobra.Command, section string) (bool, string) {
	var hasSeeAlso bool

	seealsos := make([]string, 0)
	if cmd.HasParent() {
		hasSeeAlso = true
		parentPath := cmd.Parent().CommandPath()
		dashParentPath := strings.Replace(parentPath, " ", "\\-", -1)
		seealso := fmt.Sprintf(".BR %s (%s)", dashParentPath, section)
		seealsos = append(seealsos, seealso)
		// TODO: may want to control if siblings are shown or not
		siblings := cmd.Parent().Commands()
		sort.Sort(byName(siblings))
		for _, c := range siblings {
			if !c.IsAvailableCommand() || c.IsAdditionalHelpTopicCommand() || c.Name() == cmd.Name() {
				continue
			}
			seealso := fmt.Sprintf(".BR %s\\-%s (%s)", dashParentPath, c.Name(), section)
			seealsos = append(seealsos, seealso)
		}
	}
	commandPath := cmd.CommandPath()
	dashCommandName := strings.Replace(commandPath, " ", "\\-", -1)
	children := cmd.Commands()
	sort.Sort(byName(children))
	for _, c := range children {
		if !c.IsAvailableCommand() || c.IsAdditionalHelpTopicCommand() {
			continue
		}
		hasSeeAlso = true
		seealso := fmt.Sprintf(".BR %s\\-%s (%s)", dashCommandName, c.Name(), section)
		seealsos = append(seealsos, seealso)
	}

	return hasSeeAlso, strings.Join(seealsos, ",\n")
}
